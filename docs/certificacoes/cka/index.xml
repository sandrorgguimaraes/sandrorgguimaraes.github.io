<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Diário de Bordo – Certified Kubernetes Administrator (CKA)</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/</link><description>Recent content in Certified Kubernetes Administrator (CKA) on Diário de Bordo</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><lastBuildDate>Thu, 19 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Componentes Básicos</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/01_componentes/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/01_componentes/</guid><description>
&lt;p>Um &lt;a href="https://en.wikipedia.org/wiki/Computer_cluster" target="_blank" rel="noopener">cluster&lt;/a>
Kubernetes consiste em um conjunto de máquinas de trabalho (físicas ou virtuais), chamadas &lt;a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">&lt;code>Node&lt;/code> ou &lt;code>Nó&lt;/code>&lt;/a>
que executam aplicativos em contêiner.&lt;/p>
&lt;p>Em essência existem 2 (dois) tipos de nós em um cluster Kubernetes:&lt;/p>
&lt;ul>
&lt;li>Os &lt;code>nós workers&lt;/code> que hospedam os Pods que são os componentes da carga de trabalho do aplicativo.&lt;/li>
&lt;li>Os &lt;code>nós masters&lt;/code> ou &lt;code>control plane&lt;/code> que gerenciam os &lt;code>nós works&lt;/code> e os pods no cluster.&lt;/li>
&lt;/ul>
&lt;p>Em ambiente de produção, o &lt;code>control plane&lt;/code> geralmente é executado em vários computadores e um cluster geralmente executa vários &lt;code>nós workers&lt;/code> fornecendo tolerância a falhas e alta disponibilidade.&lt;/p>
&lt;p>Em ambientes de estudo podemos ter apenas uma máquina exercendo as duas funções.&lt;/p>
&lt;h2 id="visão-geral-da-arquitetura-de-um-cluster-k8s">Visão geral da arquitetura de um cluster k8s&lt;/h2>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 849px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/01_componentes/arquitetura_k8s_hu8443cdf2387def9c2debf01304f5c329_136093_839x410_fill_box_smart1_3.png" width="839" height="410">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://medium.com/devops-mojo/kubernetes-architecture-overview-introduction-to-k8s-architecture-and-understanding-k8s-cluster-components-90e11eb34ccd" target="_blank" rel="noopener">Kubernetes — Architecture Overview&lt;/a>
.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/" target="_blank" rel="noopener">Doc K8S - Conceitos - Visão geral&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/architecture/" target="_blank" rel="noopener">Doc K8S - Conceitos - Arquitetura de cluster&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="componentes-dos-master-nodes-ou-control-plane">Componentes dos Master Nodes ou Control Plane&lt;/h2>
&lt;h3 id="etcd">ETCD&lt;/h3>
&lt;p>É um armazenamento do tipo &lt;code>chave-valor&lt;/code> distribuído e fortemente consistente que fornece uma maneira confiável de armazenar dados que precisam ser acessados ​​por um sistema distribuído ou cluster de máquinas. Ele lida com as eleições do líder durante as partições da rede e pode tolerar falhas de máquina, mesmo no nó líder.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://etcd.io/" target="_blank" rel="noopener">Site oficial&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="api-server">API Server&lt;/h3>
&lt;p>O servidor de API do Kubernetes valida e configura dados para os objetos de API que incluem pods, services, replicaSets e outros.&lt;/p>
&lt;p>O API Server atende às operações REST/kubectl e fornece o frontend para o estado compartilhado do cluster por meio do qual todos os outros componentes interagem.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" target="_blank" rel="noopener">Doc K8S - Referência - Ferramentas de componentes - kube-apiserver&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="controller-manager">Controller Manager&lt;/h3>
&lt;p>No Kubernetes, controladores são ciclos de controle que observam o estado do cluster, e então fazem ou requisitam mudanças onde e quando necessário.&lt;/p>
&lt;p>Cada controlador tenta mover o &lt;em>estado atual&lt;/em> do cluster mais perto do &lt;em>estado desejado&lt;/em>.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/pt-br/docs/concepts/architecture/controller/" target="_blank" rel="noopener">Doc K8S - Conceitos - Arquitetura do Kubernetes - Controladores&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" target="_blank" rel="noopener">Doc K8S - Referência - Ferramentas de componentes - kube-controller-manager&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="scheduler">Scheduler&lt;/h3>
&lt;p>Observa os pods recém-criados sem nenhum nó atribuído e seleciona um nó para executá-los.&lt;/p>
&lt;p>Os fatores levados em consideração para as decisões de agendamento incluem:&lt;/p>
&lt;ul>
&lt;li>Requisitos de recursos individuais e coletivos;&lt;/li>
&lt;li>Hardware/software/política de restrições;&lt;/li>
&lt;li>Especificações de afinidade e antiafinidade;&lt;/li>
&lt;li>Localidade dos dados;&lt;/li>
&lt;li>Interferência entre cargas de trabalho; e&lt;/li>
&lt;li>Prazos.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Agendador do Kubernetes&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" rel="noopener">Doc K8S - Referência - Ferramentas de componentes - kube-scheduler&lt;/a>
&lt;/li>
&lt;li>&lt;a href="../../../../blog/kubernetes/scheduler/">Vivendo &amp;amp; Aprendendo - Kubernetes - Scheduler&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="componentes-dos-worker-nodes">Componentes dos Worker Nodes&lt;/h2>
&lt;h3 id="kubelet">Kubelet&lt;/h3>
&lt;p>&lt;em>É o principal agente&lt;/em> executado em cada worker node. O kubelet usa um conjunto de PodSpecs fornecidos por meio de vários mecanismos (principalmente por meio do apiserver) e garante que os contêineres descritos nesses PodSpecs estejam em execução e íntegros.&lt;/p>
&lt;p>O kubelet não gerencia contêineres que não foram criados pelo Kubernetes.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" target="_blank" rel="noopener">Doc K8S - Referência - Ferramentas de componentes - kubelet&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="kube-proxy">Kube Proxy&lt;/h3>
&lt;p>É um proxy de rede executado em cada nó no cluster, implementando parte do conceito de serviço do Kubernetes.&lt;/p>
&lt;p>O &lt;code>kube-proxy&lt;/code> mantém regras de rede nos nós, estas regras permitem a comunicação de rede com os pods a partir de sessões de rede dentro ou fora do cluster.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" rel="noopener">Doc K8S - Referência - Ferramentas de componentes - kube-proxy&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="container-runtime">Container runtime&lt;/h3>
&lt;p>É o software responsável pela execução dos contêineres.&lt;/p>
&lt;p>O Kubernetes oferece suporte a ambientes de container runtime como o &lt;a href="https://containerd.io/docs/" target="_blank" rel="noopener">containerd&lt;/a>
, o &lt;a href="https://cri-o.io/#what-is-cri-o" target="_blank" rel="noopener">CRI-O&lt;/a>
e qualquer outra implementação do &lt;a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md" target="_blank" rel="noopener">Kubernetes CRI (Container Runtime Interface)&lt;/a>
.&lt;/p></description></item><item><title>Docs: Objetos Básicos</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/</guid><description>
&lt;h2 id="pods">POD&amp;rsquo;s&lt;/h2>
&lt;p>São as menores unidades de computação implantáveis ​​que você pode criar e gerenciar no Kubernetes.&lt;/p>
&lt;p>Um Pod modela um &amp;ldquo;host lógico&amp;rdquo; específico do aplicativo: ele contém um ou mais contêineres de aplicativos que são relativamente fortemente acoplados.&lt;/p>
&lt;p>Além dos contêineres de aplicativos, um Pod pode conter &lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" target="_blank" rel="noopener">init contêineres&lt;/a>
que são executados durante a inicialização do Pod, e também podemos injetar &lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/" target="_blank" rel="noopener">contêineres efêmeros&lt;/a>
para depuração se seu cluster oferecer isso.&lt;/p>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 678px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/pods_hu20e870202e243bd401efa252c15cb6d3_40021_668x277_fill_box_smart1_3.png" width="668" height="277">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/" target="_blank" rel="noopener">Doc K8S - Tutoriais - Aprenda o básico do Kubernetes - Explore seu aplicativo - Visualizando Pods e Nodes&lt;/a>
&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Pods&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/" target="_blank" rel="noopener">Doc K8S - Tutoriais - Aprenda o básico do Kubernetes - Explore seu aplicativo - Visualizando Pods e Nodes&lt;/a>
&lt;/li>
&lt;li>&lt;a href="../../../../blog/kubernetes/pods/">Vivendo &amp;amp; Aprendendo - Kubernetes - Pod&amp;rsquo;s&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="replicasets">ReplicaSets&lt;/h2>
&lt;p>Tem como finalidade manter um conjunto estável de réplicas de pods idênticos em execução a qualquer momento.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Recursos de carga de trabalho - ReplicaSets&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="deployments">Deployments&lt;/h2>
&lt;p>Permite atualizações declarativas para Pods e ReplicaSets.&lt;/p>
&lt;p>Você descreve um estado desejado em um Deployment e o Deployment Controller altera o estado atual para o estado desejado a uma taxa controlada.&lt;/p>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 823px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/deployments_hucef69b7a9d82d3984860a77c3f6d89b7_52410_813x346_fill_box_smart1_3.png" width="813" height="346">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://faun.pub/kubernetes-pod-naming-convention-78272fcc53ed" target="_blank" rel="noopener">Kubernetes Pod naming convention&lt;/a>
.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Recursos de carga de trabalho - Deployments&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/" target="_blank" rel="noopener">Doc K8S - Tutoriais - Aprenda o básico do Kubernetes - Implantar um aplicativo - Usando kubectl para criar um Deployment&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="services">Services&lt;/h2>
&lt;p>Uma maneira abstrata de expor um aplicativo em execução com um conjunto de Pods (normalmente gerenciados por um ReplicaSet) como um serviço de rede.&lt;/p>
&lt;p>O Kubernetes fornece um único nome DNS e endereço IP para esse conjunto de pods e pode balancear a carga entre eles.&lt;/p>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 696px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/services_hu664fc43ad0c83382baa79e172c1cde29_83574_686x509_fill_box_smart1_3.png" width="686" height="509">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/" target="_blank" rel="noopener">Doc K8S - Tutoriais - Aprenda o básico do Kubernetes - Exponha seu aplicativo publicamente - Usando um service para expor seu aplicativo&lt;/a>
&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Doc K8S - Conceitos - Services, balanceamento de carga e rede - Services&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="namespaces">Namespaces&lt;/h2>
&lt;p>No Kubernetes, os namespaces fornecem um mecanismo para isolar grupos de recursos dentro de um cluster.&lt;/p>
&lt;p>Os nomes dos recursos precisam ser exclusivos dentro do namespace, mas não entre namespaces.&lt;/p>
&lt;p>Os namespaces não podem ser aninhados uns dentro dos outros e cada recurso do Kubernetes só pode estar em um namespace.&lt;/p>
&lt;p>Os namespaces são uma maneira de dividir os recursos do cluster entre vários usuários (por meio das &lt;a href="https://kubernetes.io/docs/concepts/policy/resource-quotas/" target="_blank" rel="noopener">resources quotas&lt;/a>
).&lt;/p>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 754px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/namespaces_hu0dce226aecd7a37245248683e66a16bb_40979_744x446_fill_box_smart1_3.png" width="744" height="446">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://www.mshowto.org/kubernetes-namespace-terminating-problemi.html" target="_blank" rel="noopener">Kubernetes Namespace Terminating Problemi&lt;/a>
&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="noopener">Doc K8S - Conceitos - Visão geral - Trabalhando com objetos do Kubernetes - Namespaces&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/namespaces-walkthrough/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Passo a passo de namespaces&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Agendamento</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/03_agendamento/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/03_agendamento/</guid><description>
&lt;p>Um agendador observa os &lt;a href="../02_objetos/#pods">Pods&lt;/a>
recém-criados que não têm &lt;a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">Node&lt;/a>
atribuído. Para cada Pod que o agendador descobre, o agendador se torna responsável por encontrar o melhor &lt;a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">Node&lt;/a>
para esse Pod ser executado, uma vez concluído esse processo o &lt;a href="../01_componentes/#kubelet">Kubelet&lt;/a>
do node escolhido então coloca o pod em execução.&lt;/p>
&lt;p>O escalonador chega a esta decisão de posicionamento levando em consideração os princípios de escalonamento descritos abaixo.&lt;/p>
&lt;h2 id="agendamento-manual">Agendamento manual&lt;/h2>
&lt;p>Defina diretamente na especificação do &lt;a href="../02_objetos/#pods">Pods&lt;/a>
em qual &lt;a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">Node&lt;/a>
ele será executado.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Atribuindo pods a nós - nodeName&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="labels-e-selectors">Labels e Selectors&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Labels:&lt;/p>
&lt;ul>
&lt;li>São pares de chave/valor anexados a objetos, como pods.&lt;/li>
&lt;li>Devem ser usados ​​para especificar atributos de identificação de objetos que são significativos e relevantes para os usuários, mas não implicam diretamente na semântica do sistema central.&lt;/li>
&lt;li>Podem ser usados ​​para organizar e selecionar subconjuntos de objetos.&lt;/li>
&lt;li>Podem ser anexados a objetos no momento da criação e posteriormente adicionados e modificados a qualquer momento.&lt;/li>
&lt;li>Cada chave deve ser exclusiva para um determinado objeto.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Ao contrário de &lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names/" target="_blank" rel="noopener">nomes e UIDs&lt;/a>
, &lt;em>as labels não fornecem exclusividade&lt;/em>. Em geral, espera-se que muitos objetos tenham a(s) mesma(s) label(s).&lt;/p>
&lt;ul>
&lt;li>Selectors&lt;/li>
&lt;/ul>
&lt;p>Através de um label &lt;code>selector&lt;/code>, o cliente/usuário pode identificar um conjunto de objetos. O label selector é a primitiva de agrupamento principal no Kubernetes.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" target="_blank" rel="noopener">Doc K8S - Conceitos - Visão geral - Trabalhando com objetos do Kubernetes - Labels e Selectors&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="taints-e-tolerations">Taints e Tolerations&lt;/h2>
&lt;p>Enquanto &lt;a href="#node-affinity">Node Affinity&lt;/a>
é uma propriedade dos Pods que os atrai para um conjunto de nós (como uma preferência ou um requisito rígido), as &lt;code>Taints&lt;/code> são o oposto, elas &lt;em>permitem a um nó repelir um conjunto de pods&lt;/em>.&lt;/p>
&lt;p>As &lt;code>Tolerations&lt;/code> &lt;em>são aplicadas aos pods e permitem (mas não exigem)&lt;/em> que os pods sejam agendados em nós com &lt;code>Taints&lt;/code> correspondentes.&lt;/p>
&lt;p>As &lt;code>Taints&lt;/code> e as &lt;code>Tolerations&lt;/code> &lt;em>trabalham juntas para garantir&lt;/em> que os pods não sejam agendados em nós inadequados.&lt;/p>
&lt;p>Uma ou mais Taints pode(m) ser aplicadas a um nó, isso marca que o nó &lt;em>não deve aceitar&lt;/em> nenhum pod que não &lt;em>&lt;strong>tolere&lt;/strong>&lt;/em> essas Taints.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Taints e Tolerations&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="node-selectors">Node Selectors&lt;/h2>
&lt;p>&lt;code>nodeSelector&lt;/code> é a forma mais simples recomendada de restrição de seleção de nó.&lt;/p>
&lt;p>Ao adicionar o campo &lt;code>nodeSelector&lt;/code> à especificação do pod e definir as &lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#built-in-node-labels" target="_blank" rel="noopener">labels de nós&lt;/a>
que deseja que o nó de destino tenha, o Kubernetes agenda o pod apenas em nós que tenham cada uma das labels especificadas.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Atribuindo pods a nós - nodeSelector&lt;/a>
&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Atribuir pods a nós&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="node-affinity">Node Affinity&lt;/h2>
&lt;p>A &lt;code>Node Affinity&lt;/code> é conceitualmente semelhante a &lt;a href="#node-selectors">nodeSelector&lt;/a>
, permitindo restringir em quais nós o pod pode ser agendado com base em &lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#built-in-node-labels" target="_blank" rel="noopener">labels de nós&lt;/a>
.&lt;/p>
&lt;p>Existem dois tipos de &lt;code>Node Affinity&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>&lt;code>requiredDuringSchedulingIgnoredDuringExecution&lt;/code>: o agendador &lt;em>não pode agendar&lt;/em> o pod a menos que a regra seja atendida. Isso funciona como &lt;a href="#node-selectors">nodeSelector&lt;/a>
, &lt;em>mas com uma sintaxe mais expressiva&lt;/em>.&lt;/li>
&lt;li>&lt;code>preferredDuringSchedulingIgnoredDuringExecution&lt;/code>: o agendador &lt;em>tenta encontrar&lt;/em> um nó que atenda à regra. Se um nó correspondente não estiver disponível, o agendador &lt;em>ainda agendará&lt;/em> o pod.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Atribuindo pods a nós - Node affinity&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Atribuindo pods a nós - Affinity and anti-affinity&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Atribuir pods a nós usando afinidade de nó&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="taints-e-tolerations-x-node-affinity">Taints e Tolerations X Node Affinity&lt;/h2>
&lt;h2 id="resources-requirements-e-limits">Resources Requirements e Limits&lt;/h2>
&lt;p>Quando você define um Pod, você pode opcionalmente especificar quanto de cada recurso um Pod precisa, os recursos mais comuns a serem especificados são &lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu" target="_blank" rel="noopener">CPU&lt;/a>
e &lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory" target="_blank" rel="noopener">memória (RAM)&lt;/a>
; existem outros &lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-types" target="_blank" rel="noopener">tipos de recursos&lt;/a>
.&lt;/p>
&lt;p>Quando você especifica o &lt;code>requests&lt;/code> de um recurso para contêineres em um pod, o &lt;a href="../01_componentes/#scheduler">kube-scheduler&lt;/a>
usa essas informações para decidir em qual nó colocar o pod.&lt;/p>
&lt;p>Quando você especifica um &lt;code>limits&lt;/code> de recurso para um contêiner, o &lt;a href="../01_componentes/#kubelet">kubelet&lt;/a>
impõe esses &lt;code>limits&lt;/code> para que o contêiner em execução não tenha permissão para usar mais desse recurso do que o &lt;code>limits&lt;/code> definido.&lt;/p>
&lt;p>O &lt;a href="../01_componentes/#kubelet">kubelet&lt;/a>
também reserva pelo menos a quantidade de &lt;code>requests&lt;/code> desse recurso do sistema &lt;em>especificamente&lt;/em> para esse contêiner usar.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" target="_blank" rel="noopener">Doc K8S - Conceitos - Configuração - Gerenciamento de recursos para pods e contêineres&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Atribuir recursos de memória a contêineres e pods&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Gerenciar recursos de memória, CPU e API&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="daemonsets">DaemonSets&lt;/h2>
&lt;p>Um &lt;code>DaemonSet&lt;/code> garante que todos (ou alguns) nós executem uma cópia em um pod.&lt;/p>
&lt;p>À medida que os nós são adicionados ao cluster, os pods são adicionados a eles. À medida que os nós são removidos do cluster, esses pods são coletados como lixo.&lt;/p>
&lt;p>A exclusão de um &lt;code>DaemonSet&lt;/code> limpará os pods que ele criou.&lt;/p>
&lt;p>Alguns usos típicos de um &lt;code>DaemonSet&lt;/code> são:&lt;/p>
&lt;ul>
&lt;li>Executando um daemon de armazenamento de cluster em cada nó.&lt;/li>
&lt;li>Executando um daemon de coleta de logs em cada nó.&lt;/li>
&lt;li>Executando um daemon de monitoramento de nó em cada nó.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Recursos de carga de trabalho - DaemonSet&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/manage-daemon/" target="_blank" rel="noopener">Doc K8S - Tarefas - Gerenciar daemons de cluster&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="static-pods">Static Pods&lt;/h2>
&lt;p>Os &lt;code>Static Pods&lt;/code> são gerenciados diretamente pelo daemon &lt;a href="../01_componentes/#kubelet">kubelet&lt;/a>
em um nó específico, sem o &lt;a href="../01_componentes/#api-server">API Server&lt;/a>
observando-os.&lt;/p>
&lt;p>Enquanto a maioria dos Pods é gerenciada pelo &lt;a href="../01_componentes/#componentes-dos-master-nodes-ou-control-plane">Control Plane&lt;/a>
(por exemplo, um &lt;a href="../02_objetos/#deployments">Deployments&lt;/a>
), para &lt;code>Static Pods&lt;/code>, o &lt;a href="../01_componentes/#kubelet">kubelet&lt;/a>
supervisiona diretamente cada &lt;code>Static Pods&lt;/code> (e o reinicia se falhar).&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/#static-pods" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Pods&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Criar pods estáticos&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="multiplos-kubernetes-schedulers">Multiplos Kubernetes Schedulers&lt;/h2>
&lt;p>Se o agendador padrão não atender às suas necessidades, você pode implementar seu próprio agendador. Além disso, você pode até executar vários agendadores simultaneamente ao lado do agendador padrão e instruir o Kubernetes sobre qual agendador usar para cada um de seus pods.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/extend-kubernetes/configure-multiple-schedulers/" target="_blank" rel="noopener">Doc K8S - Tarefas - Estender Kubernetes - Configurar vários agendadores&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Log &amp; Monitoração</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/04_log_monitoracao/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/04_log_monitoracao/</guid><description>
&lt;h2 id="monitorar-os-componentes-do-cluster">Monitorar os componentes do cluster&lt;/h2>
&lt;p>Para Kubernetes, a &lt;a href="https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/#metrics-api" target="_blank" rel="noopener">API Metrics&lt;/a>
oferece um conjunto básico de métricas para dar suporte ao dimensionamento automático e casos de uso semelhantes.&lt;/p>
&lt;p>Essa API disponibiliza informações sobre o uso de recursos para nó e pod, incluindo métricas para CPU e memória.&lt;/p>
&lt;p>Se você implantar a API de métricas em seu cluster, os clientes da API do Kubernetes poderão consultar essas informações e você poderá usar os mecanismos de controle de acesso do Kubernetes para gerenciar permissões para fazer isso.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de clusters - Pipeline de métricas de recursos&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-usage-monitoring/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de clusters - Ferramentas para monitorar recursos&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Gerenciar recursos de memória, CPU e API&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="acompanhar-os-logs-das-aplicações">Acompanhar os logs das aplicações&lt;/h2>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/pt-br/docs/concepts/cluster-administration/logging/#log-b%C3%A1sico-no-kubernentes" target="_blank" rel="noopener">Doc K8S - Conceitos - Administração de Cluster - Arquitetura de Log&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-application/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de Aplicativos&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-application/debug-pods/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de Aplicativos - Debug Pods&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-application/determine-reason-pod-failure/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de Aplicativos - Determinar o motivo da falha do Pod&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Gerenciar Ciclos de Vida de Aplicações</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/05_gerenciar_apps/</link><pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/05_gerenciar_apps/</guid><description>
&lt;h2 id="rolling-updates-e-rollbacks">Rolling Updates e Rollbacks&lt;/h2>
&lt;ul>
&lt;li>&lt;code>Rolling Updates&lt;/code> permitem que a atualização de um &lt;a href="../02_objetos/#deployments">Deployment&lt;/a>
ocorra com tempo de inatividade zero, atualizando incrementalmente as instâncias de novos &lt;a href="../02_objetos/#pods">Pods&lt;/a>
.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Recursos de carga de trabalho - Deployments # Rolling Update&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/" target="_blank" rel="noopener">Doc K8S - Tutoriais - Aprenda o básico do Kubernetes - Atualize seu aplicativo - Executando um Rolling Update&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/manage-daemon/update-daemon-set/" target="_blank" rel="noopener">Doc K8S - Tarefas - Gerenciar daemons de cluster - Executar um Rolling Update em um DaemonSet&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;code>Rollbacks&lt;/code> permitem retornar a uma versão anterior de um &lt;a href="../02_objetos/#deployments">Deployment&lt;/a>
, por padrão o Kubernetes mantém um histórico de 10 versões.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Recursos de carga de trabalho - Deployments # Rollback&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/manage-daemon/rollback-daemon-set/" target="_blank" rel="noopener">Doc K8S - Tarefas - Gerenciar daemons de cluster - Executar um Rollback em um DaemonSet&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="configurando-aplicações">Configurando aplicações&lt;/h2>
&lt;p>Veremos abaixo algumas formas de permitir a portabilidade e a reusabilidade das imagens de container, usando a abordagem de separação do código da aplicação das configurações e variáveis que podemos passar durante a inicialização dos &lt;a href="../02_objetos/#pods">Pods&lt;/a>
.&lt;/p>
&lt;h3 id="comandos-e-argumentos">Comandos e Argumentos&lt;/h3>
&lt;p>O &lt;code>comando&lt;/code> e os &lt;code>argumentos&lt;/code> que definimos na especificação do Pod substituem o &lt;code>comando&lt;/code> e os &lt;code>argumentos&lt;/code> padrão fornecidos pela imagem do contêiner.&lt;/p>
&lt;p>Se definirmos &lt;code>argumentos&lt;/code>, mas não definirmos um &lt;code>comando&lt;/code>, o &lt;code>comando&lt;/code> padrão será usado com seus &lt;em>novos&lt;/em> &lt;code>argumentos&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/" target="_blank" rel="noopener">Doc K8S - Tarefas - Injetar dados em aplicativos - Definir um comando e argumentos para um contêiner&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="variáveis-de-ambiente">Variáveis de ambiente&lt;/h3>
&lt;p>Ao criarmos um &lt;a href="../02_objetos/#pods">Pod&lt;/a>
, podemos definir &lt;code>variáveis ​​de ambiente&lt;/code> para os containers executados no &lt;a href="../02_objetos/#pods">Pod&lt;/a>
, para tanto inclua o campo &lt;code>env&lt;/code> ou &lt;code>envFrom&lt;/code> na especificação do container.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/" target="_blank" rel="noopener">Doc K8S - Tarefas - Injetar dados em aplicativos - Definir variáveis ​​de ambiente para um contêiner&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/" target="_blank" rel="noopener">Doc K8S - Tarefas - Injetar dados em aplicativos - Expor informações do Pod ao container por meio de variáveis ​​de ambiente&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="configmaps">ConfigMaps&lt;/h3>
&lt;p>Um &lt;code>ConfigMap&lt;/code> é um objeto de API usado para armazenar &lt;em>dados não confidenciais&lt;/em> em pares de chave-valor.&lt;/p>
&lt;p>Os &lt;a href="../02_objetos/#pods">Pods&lt;/a>
podem consumir &lt;code>ConfigMaps&lt;/code> como variáveis ​​de ambiente, argumentos de linha de comando ou como arquivos de configuração em um volume.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/configuration/configmap/" target="_blank" rel="noopener">Doc K8S - Conceitos - Configuração - ConfigMaps&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Configurar um pod para usar um ConfigMap&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="secrets">Secrets&lt;/h3>
&lt;p>&lt;code>Secrets&lt;/code> são semelhantes aos &lt;code>ConfigMaps&lt;/code> mas destinam-se especificamente a manter &lt;em>dados confidenciais&lt;/em>.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/configuration/secret/" target="_blank" rel="noopener">Doc K8S - Conceitos - Configuração - Secrets&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configmap-secret/" target="_blank" rel="noopener">Doc K8S - Tarefas - Gerenciando Secrets&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/" target="_blank" rel="noopener">Doc K8S - Tarefas - Injetar dados em aplicativos - Distribua credenciais com segurança usando Secrets&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="pods-com-multiplos-containers">Pods com multiplos containers&lt;/h2>
&lt;p>Os &lt;a href="../02_objetos/#pods">Pods&lt;/a>
são projetados para oferecer suporte a vários processos cooperativos (como containers) que formam uma unidade de serviço coesa.&lt;/p>
&lt;p>Os containers em um &lt;a href="../02_objetos/#pods">Pod&lt;/a>
são colocados e co-agendados automaticamente na mesma máquina física ou virtual no cluster, podem compartilhar recursos e dependências, comunicar-se entre si e coordenar quando e como eles serão encerrados.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/#how-pods-manage-multiple-containers" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Pods # Como os pods gerenciam vários contêineres&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/" target="_blank" rel="noopener">Blog K8S - O kit de ferramentas do sistema distribuído: Padrões para contêineres compostos&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="initcontainers">InitContainers&lt;/h2>
&lt;p>Os &lt;code>initContainers&lt;/code> são containers especializados que são executados antes dos containers de aplicativos em um &lt;a href="../02_objetos/#pods">Pod&lt;/a>
, eles são exatamente como os containers normais, exceto que:&lt;/p>
&lt;ul>
&lt;li>Os &lt;code>initContainers&lt;/code> sempre são executados até a conclusão.&lt;/li>
&lt;li>Cada &lt;code>initContainers&lt;/code> deve ser concluído com êxito antes que o próximo seja iniciado.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Pods # Init Containers&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-initialization/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Configurar inicialização do Pod&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-application/debug-init-containers/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de aplicativos - Debug Init Containers&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="self-healing-auto-cura-das-aplicações">Self Healing (auto cura) das aplicações&lt;/h2>
&lt;p>O Kubernetes oferece suporte de self healing (auto recuperação) a aplicativos por meio de &lt;a href="../02_objetos/#replicasets">ReplicaSets&lt;/a>
.&lt;/p>
&lt;p>O &lt;a href="../02_objetos/#replicasets">ReplicaSets&lt;/a>
ajuda a garantir que um &lt;a href="../02_objetos/#pods">Pod&lt;/a>
seja recriado automaticamente quando o aplicativo dentro do &lt;a href="../02_objetos/#pods">Pod&lt;/a>
trava, isso ajuda a garantir que réplicas suficientes do aplicativo estejam em execução o tempo todo.&lt;/p>
&lt;p>O Kubernetes fornece suporte adicional para verificar a integridade dos aplicativos executados em &lt;a href="../02_objetos/#pods">Pods&lt;/a>
e realizar as ações necessárias por meio de &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-command" target="_blank" rel="noopener">Liveness Probes&lt;/a>
e &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes" target="_blank" rel="noopener">Readiness Probes&lt;/a>
, porém esses 2 (dois) tópicos são para o exame &lt;a href="https://www.cncf.io/certification/ckad/" target="_blank" rel="noopener">Certified Kubernetes Application Developers (CKAD)&lt;/a>
, não são abordados nesta certificação para CKA.&lt;/p></description></item><item><title>Docs: Manutenção do Cluster</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/06_manutencao_cluster/</link><pubDate>Thu, 09 Jun 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/06_manutencao_cluster/</guid><description>
&lt;h2 id="drain-cordon-e-uncordon">Drain, Cordon e Uncordon&lt;/h2>
&lt;p>Os comandos abaixo vão nos permitir efetuar a manutenção nos &lt;a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">Nodes&lt;/a>
de forma controlada, mitigando possíveis problemas às aplicações.&lt;/p>
&lt;ul>
&lt;li>&lt;code>cordon&lt;/code> == &lt;strong>marcar&lt;/strong> o Node como não agendável;
&lt;ul>
&lt;li>Impedindo que novos Pods sejam agendados no mesmo.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>drain&lt;/code> == &lt;strong>drenar&lt;/strong> o Node.
&lt;ul>
&lt;li>Marca o Node como não agendável (igual o &lt;code>cordon&lt;/code>) e;&lt;/li>
&lt;li>Remove todos os Pods em execução, exceto os DaemonSets, criando-os em outros Nodes.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>uncordon&lt;/code> == &lt;strong>desmarcar&lt;/strong> o Node como não agendável.
&lt;ul>
&lt;li>Permitindo que &lt;em>novas cargas&lt;/em> de trabalho / Pods sejam agendadas no mesmo.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/architecture/nodes/#manual-node-administration" target="_blank" rel="noopener">Doc K8S - Conceitos - Arquitetura de cluster - Nodes # Administração manual de Nodes&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Drain em um Nó com segurança&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="atualizando-a-versão-do-kubernetes">Atualizando a versão do Kubernetes&lt;/h2>
&lt;p>A maneira como atualizamos um cluster Kubernetes depende de como foi implantado inicialmente e das alterações realizadas posteriormente.&lt;/p>
&lt;p>Em alto nível, as etapas são:&lt;/p>
&lt;ul>
&lt;li>Atualizar os &lt;a href="../01_componentes/#componentes-dos-master-nodes-ou-control-plane">Nodes Control Plane&lt;/a>
(um Node por vez);&lt;/li>
&lt;li>Atualizar os &lt;a href="../01_componentes/#componentes-dos-worker-nodes">Nodes Workes&lt;/a>
(um Node por vez);&lt;/li>
&lt;li>Atualizar os clientes como o `kubectl;&lt;/li>
&lt;li>Ajustar manifestos e outros recursos com base nas alterações da API que acompanham a nova versão do Kubernetes;&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/cluster-upgrade/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Atualizar um cluster&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Administração com kubeadm - Como fazer upgrade de clusters kubeadm&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="backup-e-restore-etcd">Backup e Restore ETCD&lt;/h2>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Operando clusters ETCD para Kubernetes # Fazendo o backup&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://etcd.io/docs/v3.5/op-guide/recovery/" target="_blank" rel="noopener">Doc ETCD - Versões - v3.5 - Guia de Operações - Disaster Recovery&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Segurança do Cluster</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/07_seguranca/</link><pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/07_seguranca/</guid><description>
&lt;p>Em linhas gerais o que veremos a seguir é a aplicação do modelo &lt;code>4C's da segurança nativa da nuvem&lt;/code>, não necessariamente na ordem apresentada.&lt;/p>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 790px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/07_seguranca/4c_hubb291a1abaef25ea02932d8768e7b07a_49564_800x450_fit_box_3.png" width="780" height="450">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://kubernetes.io/docs/concepts/security/overview/#the-4c-s-of-cloud-native-security" target="_blank" rel="noopener">Doc K8S — Visão geral da segurança nativa da nuvem&lt;/a>
.&lt;/p>
&lt;h2 id="a-segurança-no-kubernetes">A Segurança no Kubernetes&lt;/h2>
&lt;p>O &lt;a href="../01_componentes/">Kubernetes é formado por Nodes&lt;/a>
, portanto o primeiro passo é garantir a segurança dos mesmos, &lt;em>desabilitando&lt;/em> a autenticação por senha e &lt;em>habilitando&lt;/em> a autenticação por chave SSH;&lt;/p>
&lt;p>Como a comunicação dentro de um cluster Kubernetes, os comandos, o gerenciamento, etc. passa pelo API Server, não podemos esquecer:&lt;/p>
&lt;div class="pageinfo pageinfo-primary">
&lt;p>API Server Seguro == Kubernetes Seguro&lt;/p>
&lt;/div>
&lt;p>Para manter a segurança no acesso ao API Server, precisamos pensar em:&lt;/p>
&lt;ul>
&lt;li>Quem pode acessar (&lt;em>Autenticação&lt;/em>) e;&lt;/li>
&lt;li>O que pode fazer (&lt;em>Autorização&lt;/em>);&lt;/li>
&lt;/ul>
&lt;p>Para garantir a segurança nas comunicações entre os componentes do cluster é fundamental o &lt;em>uso do TLS&lt;/em>.&lt;/p>
&lt;p>E como a premissa do Kubernetes é que todos os Pods podem se comunicar entre si, temos as &lt;em>Network Policies&lt;/em> para implementar um controle nestas comunicações.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/security/" target="_blank" rel="noopener">Doc K8S - Conceitos - Segurança&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="autenticação">Autenticação&lt;/h2>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/security/" target="_blank" rel="noopener">Doc K8S - Conceitos - Segurança&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="conceitos-básicos-sobre-tls">Conceitos básicos sobre TLS&lt;/h2>
&lt;p>O &lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">&lt;strong>TLS&lt;/strong> (&lt;em>Transport Layer Security&lt;/em>)&lt;/a>
é um protocolo de &lt;a href="https://en.wikipedia.org/wiki/Cryptography" target="_blank" rel="noopener">criptografia&lt;/a>
projetado para garantir a privacidade (confidencialidade), integridade e autenticidade na comunicação em uma rede de computadores através do uso de &lt;a href="https://en.wikipedia.org/wiki/Public_key_certificate" target="_blank" rel="noopener">certificados digitais&lt;/a>
, ele é a base do &lt;a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">&lt;strong>HTTPS&lt;/strong> (&lt;em>Hypertext Transfer Protocol Secure&lt;/em>)&lt;/a>
.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://cryptoid.com.br/banco-de-noticias/29196criptografia-simetrica-e-assimetrica/" target="_blank" rel="noopener">Criptografia Simétrica e Assimétrica: Qual a diferença entre elas?&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://cryptoid.com.br/banco-de-noticias/o-que-e-ssl-tls-e-por-que-e-hora-de-atualizar-para-tls-1-3/" target="_blank" rel="noopener">O que é SSL e TLS? E por que é hora de atualizar para TLS 1.3?&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="noopener">PKI - Public Key Infrastructure&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://www.openssl.org/docs/" target="_blank" rel="noopener">OpenSSL Project&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="tls-no-kubernetes">TLS no Kubernetes&lt;/h2>
&lt;p>No Kubernetes para garantir a comunicação segura e confiável entre os componentes nos Worker Nodes, o &lt;a href="http://localhost:1313/docs/certificacoes/cka/01_componentes/#kubelet" target="_blank" rel="noopener">kubelet&lt;/a>
e o &lt;a href="http://localhost:1313/docs/certificacoes/cka/01_componentes/#kube-proxy" target="_blank" rel="noopener">kube-proxy&lt;/a>
, e os componentes no &lt;a href="../01_componentes/#componentes-dos-master-nodes-ou-control-plane">Control Plane&lt;/a>
, principalmente o &lt;a href="http://localhost:1313/docs/certificacoes/cka/01_componentes/#api-server" target="_blank" rel="noopener">kube-apiserver&lt;/a>
é altamente recomendável usar certificados TLS.&lt;/p>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 838px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/07_seguranca/tls_hu08e91078096c6b59cf5f3c1362f8098d_152827_861x560_fit_box_3.png" width="828" height="472">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://github.com/kodekloudhub/certified-kubernetes-administrator-course/blob/master/docs/07-Security/06-TLS-in-Kubernetes.md" target="_blank" rel="noopener">Curso - Certified Kubernetes Administrator (CKA) with Practice Tests&lt;/a>
.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/" target="_blank" rel="noopener">Doc K8S - Referência - Controle de acesso à API - Inicialização de TLS&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/setup/best-practices/certificates/" target="_blank" rel="noopener">Doc K8S - Começando - Melhores Práticas - Certificados e requisitos de PKI&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/" target="_blank" rel="noopener">Doc K8S - Tarefas - TLS - Gerenciar certificados TLS em um cluster&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Administração com kubeadm - Gerenciamento de certificados com kubeadm&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/setup/best-practices/certificates/" target="_blank" rel="noopener">Curso - Certified Kubernetes Administrator (CKA) with Practice Tests - TLS in kubernetes - Certificate Creation&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="certificates-api--api-de-certificados">Certificates API / API de Certificados&lt;/h2>
&lt;p>A API de certificados permite a automação do provisionamento de credenciais X.509 fornecendo uma interface programática para clientes da API Kubernetes solicitarem e obterem certificados X.509 de uma Autoridade de Certificação (CA).&lt;/p>
&lt;p>Um recurso &lt;code>CertificateSigningRequest&lt;/code> (CSR) é usado para solicitar que um certificado seja assinado por um assinante indicado, após o qual a solicitação pode ser aprovada ou negada antes de ser finalmente assinada.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/" target="_blank" rel="noopener">Doc K8S - Referência - Controle de acesso à API - Solicitações de assinatura de certificado&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/" target="_blank" rel="noopener">Doc K8S - Tarefas - TLS - Gerenciar certificados TLS em um cluster&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="kubeconfig">KubeConfig&lt;/h2>
&lt;p>Utilize arquivos &lt;code>kubeconfig&lt;/code> para organizar informações sobre clusters, usuários, namespaces e mecanismos de autenticação. A ferramenta de linha de comando &lt;code>kubectl&lt;/code> faz uso dos arquivos &lt;code>kubeconfig&lt;/code> para encontrar as informações necessárias para escolher e se comunicar com o serviço de API de um cluster.&lt;/p>
&lt;p>Por padrão, o &lt;code>kubectl&lt;/code> procura por um arquivo de nome &lt;code>config&lt;/code> no diretório &lt;code>$HOME/.kube&lt;/code>. Você pode especificar outros arquivos kubeconfig através da variável de ambiente &lt;code>KUBECONFIG&lt;/code> ou adicionando a opção &lt;code>--kubeconfig&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/pt-br/docs/concepts/configuration/organize-cluster-access-kubeconfig/" target="_blank" rel="noopener">Doc K8S - Conceitos - Configuração - Organizando o acesso ao cluster usando arquivos kubeconfig&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="api-groups--grupos-de-api">API Groups / Grupos de API&lt;/h2>
&lt;p>Os grupos de API facilitam a extensão da API do Kubernetes. O grupo de APIs é especificado em um caminho &lt;code>REST&lt;/code> e no campo &lt;code>apiVersion&lt;/code> de um objeto serializado.&lt;/p>
&lt;p>Existem vários grupos de API no Kubernetes:&lt;/p>
&lt;ul>
&lt;li>O grupo principal ou &lt;code>core&lt;/code> (também chamado de legado) é encontrado no caminho REST &lt;code>/api/v1&lt;/code>. O grupo principal não é especificado como parte do campo &lt;code>apiVersion&lt;/code>, por exemplo, &lt;code>apiVersion: v1&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 547px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/07_seguranca/api5_hucb6c4e8aca6cad6c6f1e289d5f01a92a_120222_861x560_fit_box_3.png" width="537" height="409">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://github.com/kodekloudhub/certified-kubernetes-administrator-course/blob/master/docs/07-Security/15-API-Groups.md" target="_blank" rel="noopener">Curso - Certified Kubernetes Administrator (CKA) with Practice Tests&lt;/a>
.&lt;/p>
&lt;ul>
&lt;li>Os grupos nomeados estão no caminho REST &lt;code>/apis/$GROUP_NAME/$VERSION&lt;/code> e usam &lt;code>apiVersion: $GROUP_NAME/$VERSION&lt;/code> (por exemplo, &lt;code>apiVersion: batch/v1&lt;/code>). Podemos encontrar a lista completa de grupos de API compatíveis na &lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#-strong-api-groups-strong-" target="_blank" rel="noopener">referência da API do Kubernetes&lt;/a>
.&lt;/li>
&lt;/ul>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 871px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/07_seguranca/api6_hu50a1f89d54766dfc4e5965dbd3ed2ee6_267325_861x560_fit_box_3.png" width="861" height="479">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://github.com/kodekloudhub/certified-kubernetes-administrator-course/blob/master/docs/07-Security/15-API-Groups.md" target="_blank" rel="noopener">Curso - Certified Kubernetes Administrator (CKA) with Practice Tests&lt;/a>
.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="noopener">Doc K8S - Conceitos - Visão geral - A API do Kubernetes&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/using-api/" target="_blank" rel="noopener">Doc K8S - Referência - Configuração - Visão geral da API&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/" target="_blank" rel="noopener">Doc K8S - Referência - API do Kubernetes&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="autorização">Autorização&lt;/h2>
&lt;p>O Kubernetes autoriza solicitações de API usando o API Server. Ele avalia todos os atributos de solicitação em relação a todas as políticas e permite ou nega a solicitação. Todas as partes de uma solicitação de API devem ser permitidas por alguma política para prosseguir. &lt;em>Isso significa que as permissões são negadas por padrão&lt;/em>.&lt;/p>
&lt;p>Quando vários módulos de autorização são configurados, cada um é verificado em sequência. Se algum autorizador aprovar ou negar um pedido, &lt;em>essa decisão é imediatamente devolvida&lt;/em> e &lt;em>nenhum outro autorizador é consultado&lt;/em>. Se todos os módulos não tiverem opinião sobre a solicitação, &lt;em>a solicitação será negada&lt;/em>. Uma negação retorna um código de status HTTP 403.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" target="_blank" rel="noopener">Doc K8S - Referência - Controle de acesso à API - Visão geral da autorização&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="rbac-role-based-access-control">RBAC (Role-Based Access Control)&lt;/h2>
&lt;p>O &lt;strong>RBAC&lt;/strong> (&lt;em>Role-Based Access Control&lt;/em> ou Controle de Acesso Baseado em Função) é um método de regular o acesso a recursos de computador ou rede com base nas funções de usuários individuais em sua organização.&lt;/p>
&lt;p>A autorização &lt;strong>RBAC&lt;/strong> usa o &lt;code>rbac.authorization.k8s.io&lt;/code> &lt;a href="#grupos-de-api">Grupo de API&lt;/a>
para orientar as decisões de autorização, permitindo configurar políticas dinamicamente por meio da API do Kubernetes.&lt;/p>
&lt;p>Para habilitar o &lt;strong>RBAC&lt;/strong>, inicie o API Server com o sinalizador &lt;code>--authorization-modes&lt;/code> definido para uma lista separada por vírgulas que inclua &lt;code>RBAC&lt;/code>, por exemplo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kube-apiserver --authorization-mode&lt;span style="color:#f92672">=&lt;/span>Example,RBAC --other-options --more-options
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">Doc K8S - Referência - Controle de acesso à API - Usando autorização RBAC&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#command-line-utilities" target="_blank" rel="noopener">Doc K8S - Referência - Controle de acesso à API - Usando autorização RBAC # Utilitários de linha de comando&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="cluster-roles-e-role-bindings">Cluster Roles e Role Bindings&lt;/h2>
&lt;p>Uma &lt;code>Role&lt;/code> ou &lt;code>ClusterRole&lt;/code> &lt;a href="#rbac-role-based-access-control">RBAC&lt;/a>
contém regras que representam um conjunto de permissões. &lt;em>As permissões são puramente aditivas&lt;/em> (não há regras de &amp;ldquo;negação&amp;rdquo;).&lt;/p>
&lt;ul>
&lt;li>Uma &lt;code>Role&lt;/code> sempre define permissões em um determinado &lt;code>namespace&lt;/code>; ao criar uma &lt;code>Role&lt;/code>, precisa ser especificado o &lt;code>namespace&lt;/code> ao qual ela pertence.&lt;/li>
&lt;li>&lt;code>ClusterRole&lt;/code>, por outro lado, é um recurso &lt;em>sem namespace&lt;/em>, se aplica ao cluster inteiro.&lt;/li>
&lt;/ul>
&lt;p>Os recursos têm nomes diferentes (&lt;code>Role&lt;/code> e &lt;code>ClusterRole&lt;/code>) porque um objeto Kubernetes sempre precisa ter namespace ou não; não pode ser os dois.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole" target="_blank" rel="noopener">Doc K8S - Referência - Controle de acesso à API - Usando autorização RBAC # Role e ClusterRole&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#command-line-utilities" target="_blank" rel="noopener">Doc K8S - Referência - Controle de acesso à API - Usando autorização RBAC # Utilitários de linha de comando&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="services-accounts--contas-de-serviços">Services Accounts / Contas de Serviços&lt;/h2>
&lt;p>Segue abaixo algumas caracteristicas das &lt;em>Services Accounts&lt;/em> ou Contas de Serviço:&lt;/p>
&lt;ul>
&lt;li>São para processos, que são executados em pods.&lt;/li>
&lt;li>São vinculadas a um namespace.&lt;/li>
&lt;li>Processo de criação mais leve, permitindo que os usuários do cluster criem contas de serviço para tarefas específicas seguindo o princípio de privilégio mínimo.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/" target="_blank" rel="noopener">Doc K8S - Referência - Controle de acesso à API - Como gerenciar Services Accounts&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Configurar contas de serviço para pods&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="segurança-de-imagens">Segurança de Imagens&lt;/h2>
&lt;p>Uma imagem de container representa dados binários que encapsulam um aplicativo e todas as suas dependências de software, são pacotes de software executáveis ​​que podem ser executados de forma independente e que fazem suposições muito bem definidas sobre seu ambiente de tempo de execução.&lt;/p>
&lt;p>Normalmente se cria uma imagem de contêiner de seu aplicativo e a envia para um registro antes de se referir a ela em um Pod.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/containers/images/" target="_blank" rel="noopener">Doc K8S - Conceitos - Containers - Imagens&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="security-context-ou-contexto-de-segurança">Security Context ou Contexto de Segurança&lt;/h2>
&lt;p>Os &lt;em>Security Contexts&lt;/em> configuram Pods e Containers em tempo de execução.&lt;/p>
&lt;p>Os &lt;em>Security Contexts&lt;/em> são definidos como parte das especificações do Pod e do Container no manifesto do Pod e representam parâmetros para o tempo de execução do container.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar Pods e Containers - Configurar um Security Context para um Pod ou Container&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="network-policy">Network Policy&lt;/h2>
&lt;p>Por padrão todas as conexões de entrada e saída em um Pod são permitidas, as &lt;em>Network Policies&lt;/em> implementam um controle no fluxo do tráfego tanto de entrada &lt;code>Ingress&lt;/code>, quanto de saída &lt;code>Egress&lt;/code>.&lt;/p>
&lt;p>As &lt;em>Network Policies&lt;/em> não entram em conflito, elas são aditivas. Se alguma política ou políticas se aplicarem a um determinado Pod para uma determinada direção, as conexões permitidas nessa direção desse Pod serão a união do que as políticas aplicáveis ​​permitem. Assim, a ordem de avaliação não afeta o resultado da política.&lt;/p>
&lt;p>Para que uma conexão de um Pod de origem a um Pod de destino seja permitida, a política de saída no Pod de origem e a política de entrada no Pod de destino precisam permitir a conexão, se um dos lados não permitir a conexão, ela não acontecerá.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" target="_blank" rel="noopener">Doc K8S - Conceitos - Serviços, balanceamento de carga e rede - Network Policy&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Armazenamento</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/08_armazenamento/</link><pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/08_armazenamento/</guid><description>
&lt;h2 id="conceitos-sobre-armazenamento-em-containers">Conceitos sobre armazenamento em Containers&lt;/h2>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.docker.com/storage/" target="_blank" rel="noopener">Doc Docker - Execute seu aplicativo em produção - Gerenciar dados do aplicativo - Visão geral do armazenamento&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/storage/storagedriver/" target="_blank" rel="noopener">Doc Docker - Execute seu aplicativo em produção - Gerenciar dados do aplicativo - Armazenar dados em contêineres&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="volumes">Volumes&lt;/h2>
&lt;p>O sistema de arquivos de um Container vive apenas enquanto o Container existir. Portanto, quando um Container é encerrado e reiniciado, as alterações no sistema de arquivos são perdidas.&lt;/p>
&lt;p>A abstração de &lt;code>Volumes&lt;/code> do Kubernetes resolve este problema, fornecendo um armazenamento mais consistente e independente do Container, o que é especialmente importante para aplicativos com estado, como bancos de dados.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">Doc K8S - Conceitos - Armazenar - Volumes&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/storage/volumes/#out-of-tree-volume-plugins" target="_blank" rel="noopener">Doc K8S - Conceitos - Armazenar - Volumes # Plugins&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="persistent-volumes-pv">Persistent Volumes (PV)&lt;/h2>
&lt;p>Um &lt;code>Persistent Volume&lt;/code> (PV) é uma parte do armazenamento no cluster que foi provisionado por um administrador ou provisionado dinamicamente usando &lt;code>Storage Class&lt;/code>.&lt;/p>
&lt;p>É um recurso no cluster, assim como um nó é um recurso de cluster.&lt;/p>
&lt;p>&lt;code>PVs&lt;/code> são plugins de volume como Volumes, mas têm um ciclo de vida independente de qualquer Pod individual que use o &lt;code>PV&lt;/code>.&lt;/p>
&lt;p>Esse objeto de API captura os detalhes da implementação do armazenamento, seja NFS, iSCSI ou um sistema de armazenamento específico do provedor de nuvem.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener">Doc K8S - Conceitos - Armazenar - Persistent Volumes&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Configurar um pod para usar um Persistent Volume&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="persistent-volumes-claims-pvc">Persistent Volumes Claims (PVC)&lt;/h2>
&lt;p>Um &lt;code>Persistent Volume Claim&lt;/code> (PVC) é uma solicitação de armazenamento feita por um usuário, é semelhante a um Pod.&lt;/p>
&lt;p>Enquanto os pods consomem recursos do nó, os &lt;code>PVCs&lt;/code> consomem recursos dos &lt;code>PV&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims" target="_blank" rel="noopener">Doc K8S - Conceitos - Armazenar - Persistent Volumes Claims&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="storage-class">Storage Class&lt;/h2>
&lt;p>Um &lt;code>Storage Class&lt;/code> fornece uma maneira para os administradores descreverem as &amp;ldquo;classes&amp;rdquo; de armazenamento que eles oferecem.&lt;/p>
&lt;p>Classes diferentes podem ser mapeadas para níveis de qualidade de serviço, políticas de backup ou políticas arbitrárias determinadas pelos administradores de cluster.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/storage/storage-classes/" target="_blank" rel="noopener">Doc K8S - Conceitos - Armazenar - Storage Class&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Altere o Storage Class padrão&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Network</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/09_network/</link><pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/09_network/</guid><description>
&lt;h2 id="conceitos-básicos-de-redes">Conceitos básicos de Redes&lt;/h2>
&lt;p>Abaixo alguns tópicos básicos para direcionar o entendimento sobre o funcionamento de uma rede de computadores:&lt;/p>
&lt;h3 id="geral">Geral&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kodekloudhub/certified-kubernetes-administrator-course/blob/master/docs/09-Networking/02-Pre-requisite-Switching-Routing-Gateways.md" target="_blank" rel="noopener">Switching / Routing / Gateway&lt;/a>
;&lt;/li>
&lt;li>&lt;a href="https://github.com/kodekloudhub/certified-kubernetes-administrator-course/blob/master/docs/09-Networking/03-Pre-requisite-DNS.md" target="_blank" rel="noopener">DNS&lt;/a>
;&lt;/li>
&lt;li>&lt;a href="https://github.com/coredns/coredns" target="_blank" rel="noopener">coreDNS&lt;/a>
;&lt;/li>
&lt;/ul>
&lt;h3 id="linux--container">Linux / Container&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kodekloudhub/certified-kubernetes-administrator-course/blob/master/docs/09-Networking/05-Pre-requisite-Network-Namespace.md" target="_blank" rel="noopener">Network Namespaces no Linux&lt;/a>
;&lt;/li>
&lt;li>&lt;a href="https://github.com/kodekloudhub/certified-kubernetes-administrator-course/blob/master/docs/09-Networking/06-Pre-requisite-Docker-Networking.md" target="_blank" rel="noopener">Docker Network&lt;/a>
;&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://sandrorgguimaraes.github.io/blog/linux/container-networking/">Vivendo &amp;amp; Aprendendo - Linux - Container Networking&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="kubernetes">Kubernetes&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://coredns.io/plugins/kubernetes/" target="_blank" rel="noopener">Plugin do coreDNS para o Kubernetes&lt;/a>
;&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/dns/blob/master/docs/specification.md" target="_blank" rel="noopener">Especificação do serviço DNS para o Kubernetes&lt;/a>
;&lt;/li>
&lt;li>&lt;a href="https://github.com/kodekloudhub/certified-kubernetes-administrator-course/blob/master/docs/09-Networking/07-Pre-requisite-CNI.md" target="_blank" rel="noopener">Container Network Interface(CNI)&lt;/a>
;&lt;/li>
&lt;/ul>
&lt;h2 id="cluster-networking">Cluster Networking&lt;/h2>
&lt;p>A rede é uma parte central do Kubernetes, e pode ser um desafio entender exatamente como ela deve funcionar, existem 4 problemas de rede distintos para resolver:&lt;/p>
&lt;ul>
&lt;li>Comunicações de container a container altamente acopladas: isso é resolvido pelos Pods e comunicação &lt;code>localhost&lt;/code>.&lt;/li>
&lt;li>Comunicações &lt;code>Pod-to-Pod&lt;/code>.&lt;/li>
&lt;li>Comunicações &lt;code>Pod-to-Service&lt;/code>.&lt;/li>
&lt;li>Comunicações externas ao serviço.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/networking/" target="_blank" rel="noopener">Doc K8S - Conceitos - Estendendo Kubernetes - Cluster Networking&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/#the-kubernetes-network-model" target="_blank" rel="noopener">Doc K8S - Conceitos - Services, Load Balancing, and Networking # O modelo de rede do Kubernetes&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://sandrorgguimaraes.github.io/blog/kubernetes/network/">Vivendo &amp;amp; Aprendendo - Kubernetes - Network&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="pod-networking">Pod Networking&lt;/h2>
&lt;p>Cada Pod recebe um endereço IP exclusivo para cada família de endereços. Cada container do Pod compartilha o &lt;code>network namespace&lt;/code>, incluindo o endereço IP e as portas de rede.&lt;/p>
&lt;p>Dentro do Pod, os containers se comunicam entre si usando &lt;code>localhost&lt;/code>.&lt;/p>
&lt;p>Quando os contêineres em um Pod se comunicam com entidades fora do Pod, eles devem coordenar como usam os recursos de rede compartilhados (como portas).&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/#pod-networking" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Pods # Networking&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pods" target="_blank" rel="noopener">Doc K8S - Conceitos - Serviços, balanceamento de carga e rede - DNS para Pods&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="container-networking-interface-cni-no-kubernetes">Container Networking Interface (CNI) no Kubernetes&lt;/h2>
&lt;p>O Kubernetes oferece suporte a plugins &lt;em>Container Network Interface&lt;/em> (CNI) para redes de cluster, escolha um que seja compatível com o cluster e que atenda às suas necessidades, diferentes plugins estão disponíveis (tanto de código aberto quanto de código fechado) no ecossistema Kubernetes.&lt;/p>
&lt;p>Um plug-in CNI é necessário para implementar o &lt;a href="https://kubernetes.io/docs/concepts/services-networking/#the-kubernetes-network-model" target="_blank" rel="noopener">modelo de rede Kubernetes&lt;/a>
.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>IP Address Management in the Kubernetes Cluster&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 890px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/09_network/net3_hu32797f3345fcda588beec40960424fba_271123_880x470_fit_box_3.png" width="880" height="470">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://github.com/kodekloudhub/certified-kubernetes-administrator-course/blob/master/docs/09-Networking/15-ipam-weave.md" target="_blank" rel="noopener">Curso - Certified Kubernetes Administrator (CKA) with Practice Tests&lt;/a>
.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/" target="_blank" rel="noopener">Doc K8S - Conceitos - Administração de cluster - Extensões de computação, armazenamento e rede - Network Plugins&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">Doc K8S - Conceitos - Administração de cluster - Instalando Addons&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://www.weave.works/docs/net/latest/kubernetes/kube-addon/" target="_blank" rel="noopener">Doc WeaveWorks - Integrating Kubernetes via the Addon&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="service-networking">Service Networking&lt;/h2>
&lt;p>Uma maneira abstrata de expor um aplicativo em execução em um &lt;em>conjunto de Pods&lt;/em> é através de um &lt;code>Service&lt;/code> ou serviço de rede.&lt;/p>
&lt;p>Com o Kubernetes, você não precisa modificar seu aplicativo para usar um mecanismo de descoberta de serviço desconhecido. O Kubernetes fornece aos Pods seus próprios endereços IP e &lt;em>um único nome DNS&lt;/em> para um conjunto de pods e pode balancear a carga entre eles.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Doc K8S - Conceitos - Serviços, balanceamento de carga e rede - Services&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#services" target="_blank" rel="noopener">Doc K8S - Conceitos - Serviços, balanceamento de carga e rede - DNS para Services&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/" target="_blank" rel="noopener">Doc K8S - Conceitos - Serviços, balanceamento de carga e rede - Conectando aplicativos com Services&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/dns-debugging-resolution/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Debugging DNS Resolution&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="ingress">Ingress&lt;/h2>
&lt;p>O &lt;code>Ingress&lt;/code> expõe rotas &lt;code>HTTP/HTTPS&lt;/code> de fora do cluster para &lt;code>Services&lt;/code> dentro do cluster, pode atuar como balanceador de carga, aplicar SSL/TLS e oferecer hospedagem virtual baseada em nome.&lt;/p>
&lt;p>É necessário ter um &lt;code>Ingress Controller&lt;/code> para satisfazer um Ingress. Apenas a criação de um &lt;code>Ingress resource&lt;/code> não tem efeito.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener">Doc K8S - Conceitos - Serviços, balanceamento de carga e rede - Ingress&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" target="_blank" rel="noopener">Doc K8S - Conceitos - Serviços, balanceamento de carga e rede - Ingress Controller&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/" target="_blank" rel="noopener">Doc K8S - Tarefas - Acessando aplicações no Cluster - Configurando um Ingress no Minikube com o NGINX Ingress Controller&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Dicas</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/10_dicas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/10_dicas/</guid><description>
&lt;p>Segue abaixo um compilado de várias dicas que pegamos durante a preparação para a prova que acredito vá ajudar a todos.&lt;/p>
&lt;ol>
&lt;li>Pratique, pratique e pratique&amp;hellip; e depois volte e pratique mais um pouco.
&lt;ul>
&lt;li>Nesta nossa &lt;a href="../../cka/">trilha de estudos&lt;/a>
encontraremos em cada tópico &lt;code>Link's úteis&lt;/code> e sempre que possível teremos um link direto para &lt;code>Doc K8S - Tarefas&lt;/code> específica, vá lá e faça o exercício.&lt;/li>
&lt;li>Na &lt;a href="https://kubernetes.io/docs/tasks/" target="_blank" rel="noopener">documentação oficial do Kubernetes&lt;/a>
tem disponível muitos exercícios, veja os que estão relacionados ao &lt;a href="https://github.com/cncf/curriculum" target="_blank" rel="noopener">curriculo da certificação&lt;/a>
e faça-os também.&lt;/li>
&lt;li>&lt;a href="https://killercoda.com/killer-shell-cka" target="_blank" rel="noopener">KillerCoda - CKA&lt;/a>
é um ambiente interativo com vários exercícios.&lt;/li>
&lt;li>Repositório &lt;a href="https://github.com/StenlyTU/K8s-training-official" target="_blank" rel="noopener">K8s Practice Training&lt;/a>
cotém alguns exercícios.&lt;/li>
&lt;li>Site &lt;a href="https://kubebyexample.com/" target="_blank" rel="noopener">Kube by Example&lt;/a>
.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Estude sobre a estrutura dos arquivos &lt;code>.yaml&lt;/code> / &lt;code>.json&lt;/code> e aprenda a fazer consultas utilizando o &lt;code>JSON PATH&lt;/code>.
&lt;ul>
&lt;li>Curso gratuito:
&lt;ul>
&lt;li>&lt;a href="https://kodekloud.com/courses/json-path-quiz/?no_frame=1" target="_blank" rel="noopener">JSON Path Test – Free Course&lt;/a>
da &lt;a href="https://kodekloud.com/" target="_blank" rel="noopener">KodeKloud&lt;/a>
.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Sites:
&lt;ul>
&lt;li>&lt;a href="https://jsonpath.com/" target="_blank" rel="noopener">JSONPath Online Evaluator&lt;/a>
.&lt;/li>
&lt;li>&lt;a href="https://goessner.net/articles/JsonPath/index.html#e2" target="_blank" rel="noopener">JSONPath expressions&lt;/a>
.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Otimize o seu ambiente, criando &lt;code>alias&lt;/code> e &lt;code>variáveis de ambiente&lt;/code>, para poupar preciosos segundos durante a avaliação. Comece a fazer isso já durante os simulados até decorar (lembre-se que no dia da prova não terá acesso a recursos externos).
&lt;ul>
&lt;li>
&lt;p>No arquivo &lt;code>~/.bashrc&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Estes 3 (três) primeiros comandos não precisa decorar.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Criação do alias `k` e configuração do autocomplete já devem estar pré configurados no ambiente&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># mas vale a pena conferir, na dúvida consulte a documentação oficial procurando por&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># `kubectl cheat` e ir para a página https://kubernetes.io/docs/reference/kubectl/cheatsheet/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;kubectl&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source &amp;lt;&lt;span style="color:#f92672">(&lt;/span>kubectl completion bash&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>complete -o default -F __start_kubectl k
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Já os 4 (quatro) comandos abaixo, será necessário decorar.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># O comando para alterar de contexto / cluster normalmente é dado na questão,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># mas para alterar entre os namespaces não.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Exemplo de uso:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># kns &amp;lt;nome-do-namespace&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias kns&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;kubectl config set-context --current --namespace&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Para agilizar a criação de objetos via manifestos (arquivos .yaml)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Exemplo de uso:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ka &amp;lt;nome-do-arquivo&amp;gt;.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias ka&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;kubectl apply -f&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Para facilitar a validação dos comandos e geração dos manifestos (arquivos .yaml).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Exemplos de uso:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># k run &amp;lt;nome-pod&amp;gt; --image=&amp;lt;nome-da-image&amp;gt; $do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># k run &amp;lt;nome-pod&amp;gt; --image=&amp;lt;nome-da-image&amp;gt; $do &amp;gt; &amp;lt;nome-do-arquivo&amp;gt;.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export &lt;span style="color:#66d9ef">do&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;--dry-run=client -o yaml&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Para não esperar pela exclusão de um objeto.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Exemplo de uso:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># k delete pod &amp;lt;nome-do-pod&amp;gt; $now&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export now&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;--force --grace-period 0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>No arquivo &lt;code>~/.vimrc&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>set autoindent expandtab tabstop&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> shiftwidth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ou&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>set autoindent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set expandtab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set tabstop&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set shiftwidth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Neste artigo &lt;a href="https://linuxhandbook.com/vim-indentation-tab-spaces/" target="_blank" rel="noopener">Set Indentation Width to 2 or 4 Spaces (or Tab) in Vim&lt;/a>
tem uma explicação direta e objetiva sobre essas configurações.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item></channel></rss>