<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Diário de Bordo – Certified Kubernetes Administrator (CKA)</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/</link><description>Recent content in Certified Kubernetes Administrator (CKA) on Diário de Bordo</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><lastBuildDate>Thu, 19 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Componentes Básicos</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/01_componentes/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/01_componentes/</guid><description>
&lt;p>Um &lt;a href="https://en.wikipedia.org/wiki/Computer_cluster" target="_blank" rel="noopener">cluster&lt;/a>
Kubernetes consiste em um conjunto de máquinas de trabalho (físicas ou virtuais), chamadas &lt;a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">&lt;code>Node&lt;/code> ou &lt;code>Nó&lt;/code>&lt;/a>
que executam aplicativos em contêiner.&lt;/p>
&lt;p>Em essência existem 2 (dois) tipos de nós em um cluster Kubernetes:&lt;/p>
&lt;ul>
&lt;li>Os &lt;code>nós workers&lt;/code> que hospedam os Pods que são os componentes da carga de trabalho do aplicativo.&lt;/li>
&lt;li>Os &lt;code>nós masters&lt;/code> ou &lt;code>control plane&lt;/code> que gerenciam os &lt;code>nós works&lt;/code> e os pods no cluster.&lt;/li>
&lt;/ul>
&lt;p>Em ambiente de produção, o &lt;code>control plane&lt;/code> geralmente é executado em vários computadores e um cluster geralmente executa vários &lt;code>nós workers&lt;/code> fornecendo tolerância a falhas e alta disponibilidade.&lt;/p>
&lt;p>Em ambientes de estudo podemos ter apenas uma máquina exercendo as duas funções.&lt;/p>
&lt;h2 id="visão-geral-da-arquitetura-de-um-cluster-k8s">Visão geral da arquitetura de um cluster k8s&lt;/h2>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 849px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/01_componentes/arquitetura_k8s_hu8443cdf2387def9c2debf01304f5c329_136093_839x410_fill_box_smart1_3.png" width="839" height="410">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://medium.com/devops-mojo/kubernetes-architecture-overview-introduction-to-k8s-architecture-and-understanding-k8s-cluster-components-90e11eb34ccd" target="_blank" rel="noopener">Kubernetes — Architecture Overview&lt;/a>
.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/" target="_blank" rel="noopener">Doc K8S - Conceitos - Visão geral&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/architecture/" target="_blank" rel="noopener">Doc K8S - Conceitos - Arquitetura de cluster&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="componentes-dos-master-nodes-ou-control-plane">Componentes dos Master Nodes ou Control Plane&lt;/h2>
&lt;h3 id="etcd">ETCD&lt;/h3>
&lt;p>É um armazenamento do tipo &lt;code>chave-valor&lt;/code> distribuído e fortemente consistente que fornece uma maneira confiável de armazenar dados que precisam ser acessados ​​por um sistema distribuído ou cluster de máquinas. Ele lida com as eleições do líder durante as partições da rede e pode tolerar falhas de máquina, mesmo no nó líder.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://etcd.io/" target="_blank" rel="noopener">Site oficial&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="api-server">API Server&lt;/h3>
&lt;p>O servidor de API do Kubernetes valida e configura dados para os objetos de API que incluem pods, services, replicaSets e outros.&lt;/p>
&lt;p>O API Server atende às operações REST/kubectl e fornece o frontend para o estado compartilhado do cluster por meio do qual todos os outros componentes interagem.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" target="_blank" rel="noopener">Doc K8S - Referência - Ferramentas de componentes - kube-apiserver&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="controller-manager">Controller Manager&lt;/h3>
&lt;p>No Kubernetes, controladores são ciclos de controle que observam o estado do cluster, e então fazem ou requisitam mudanças onde e quando necessário.&lt;/p>
&lt;p>Cada controlador tenta mover o &lt;em>estado atual&lt;/em> do cluster mais perto do &lt;em>estado desejado&lt;/em>.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/pt-br/docs/concepts/architecture/controller/" target="_blank" rel="noopener">Doc K8S - Conceitos - Arquitetura do Kubernetes - Controladores&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" target="_blank" rel="noopener">Doc K8S - Referência - Ferramentas de componentes - kube-controller-manager&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="scheduler">Scheduler&lt;/h3>
&lt;p>Observa os pods recém-criados sem nenhum nó atribuído e seleciona um nó para executá-los.&lt;/p>
&lt;p>Os fatores levados em consideração para as decisões de agendamento incluem:&lt;/p>
&lt;ul>
&lt;li>Requisitos de recursos individuais e coletivos;&lt;/li>
&lt;li>Hardware/software/política de restrições;&lt;/li>
&lt;li>Especificações de afinidade e antiafinidade;&lt;/li>
&lt;li>Localidade dos dados;&lt;/li>
&lt;li>Interferência entre cargas de trabalho; e&lt;/li>
&lt;li>Prazos.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Agendador do Kubernetes&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" rel="noopener">Doc K8S - Referência - Ferramentas de componentes - kube-scheduler&lt;/a>
&lt;/li>
&lt;li>&lt;a href="../../../../blog/kubernetes/scheduler/">Vivendo &amp;amp; Aprendendo - Kubernetes - Scheduler&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="componentes-dos-worker-nodes">Componentes dos Worker Nodes&lt;/h2>
&lt;h3 id="kubelet">Kubelet&lt;/h3>
&lt;p>&lt;em>É o principal agente&lt;/em> executado em cada worker node. O kubelet usa um conjunto de PodSpecs fornecidos por meio de vários mecanismos (principalmente por meio do apiserver) e garante que os contêineres descritos nesses PodSpecs estejam em execução e íntegros.&lt;/p>
&lt;p>O kubelet não gerencia contêineres que não foram criados pelo Kubernetes.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" target="_blank" rel="noopener">Doc K8S - Referência - Ferramentas de componentes - kubelet&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="kube-proxy">Kube Proxy&lt;/h3>
&lt;p>É um proxy de rede executado em cada nó no cluster, implementando parte do conceito de serviço do Kubernetes.&lt;/p>
&lt;p>O &lt;code>kube-proxy&lt;/code> mantém regras de rede nos nós, estas regras permitem a comunicação de rede com os pods a partir de sessões de rede dentro ou fora do cluster.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" rel="noopener">Doc K8S - Referência - Ferramentas de componentes - kube-proxy&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="container-runtime">Container runtime&lt;/h3>
&lt;p>É o software responsável pela execução dos contêineres.&lt;/p>
&lt;p>O Kubernetes oferece suporte a ambientes de container runtime como o &lt;a href="https://containerd.io/docs/" target="_blank" rel="noopener">containerd&lt;/a>
, o &lt;a href="https://cri-o.io/#what-is-cri-o" target="_blank" rel="noopener">CRI-O&lt;/a>
e qualquer outra implementação do &lt;a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md" target="_blank" rel="noopener">Kubernetes CRI (Container Runtime Interface)&lt;/a>
.&lt;/p></description></item><item><title>Docs: Objetos Básicos</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/</guid><description>
&lt;h2 id="pods">POD&amp;rsquo;s&lt;/h2>
&lt;p>São as menores unidades de computação implantáveis ​​que você pode criar e gerenciar no Kubernetes.&lt;/p>
&lt;p>Um Pod modela um &amp;ldquo;host lógico&amp;rdquo; específico do aplicativo: ele contém um ou mais contêineres de aplicativos que são relativamente fortemente acoplados.&lt;/p>
&lt;p>Além dos contêineres de aplicativos, um Pod pode conter &lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" target="_blank" rel="noopener">init contêineres&lt;/a>
que são executados durante a inicialização do Pod, e também podemos injetar &lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/" target="_blank" rel="noopener">contêineres efêmeros&lt;/a>
para depuração se seu cluster oferecer isso.&lt;/p>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 678px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/pods_hu20e870202e243bd401efa252c15cb6d3_40021_668x277_fill_box_smart1_3.png" width="668" height="277">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/" target="_blank" rel="noopener">Doc K8S - Tutoriais - Aprenda o básico do Kubernetes - Explore seu aplicativo - Visualizando Pods e Nodes&lt;/a>
&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Pods&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/" target="_blank" rel="noopener">Doc K8S - Tutoriais - Aprenda o básico do Kubernetes - Explore seu aplicativo - Visualizando Pods e Nodes&lt;/a>
&lt;/li>
&lt;li>&lt;a href="../../../../blog/kubernetes/pods/">Vivendo &amp;amp; Aprendendo - Kubernetes - Pod&amp;rsquo;s&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="replicasets">ReplicaSets&lt;/h2>
&lt;p>Tem como finalidade manter um conjunto estável de réplicas de pods idênticos em execução a qualquer momento.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Recursos de carga de trabalho - ReplicaSets&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="deployments">Deployments&lt;/h2>
&lt;p>Permite atualizações declarativas para Pods e ReplicaSets.&lt;/p>
&lt;p>Você descreve um estado desejado em um Deployment e o Deployment Controller altera o estado atual para o estado desejado a uma taxa controlada.&lt;/p>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 823px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/deployments_hucef69b7a9d82d3984860a77c3f6d89b7_52410_813x346_fill_box_smart1_3.png" width="813" height="346">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://faun.pub/kubernetes-pod-naming-convention-78272fcc53ed" target="_blank" rel="noopener">Kubernetes Pod naming convention&lt;/a>
.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Recursos de carga de trabalho - Deployments&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/" target="_blank" rel="noopener">Doc K8S - Tutoriais - Aprenda o básico do Kubernetes - Implantar um aplicativo - Usando kubectl para criar um Deployment&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="services">Services&lt;/h2>
&lt;p>Uma maneira abstrata de expor um aplicativo em execução com um conjunto de Pods (normalmente gerenciados por um ReplicaSet) como um serviço de rede.&lt;/p>
&lt;p>O Kubernetes fornece um único nome DNS e endereço IP para esse conjunto de pods e pode balancear a carga entre eles.&lt;/p>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 696px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/services_hu664fc43ad0c83382baa79e172c1cde29_83574_686x509_fill_box_smart1_3.png" width="686" height="509">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/" target="_blank" rel="noopener">Doc K8S - Tutoriais - Aprenda o básico do Kubernetes - Exponha seu aplicativo publicamente - Usando um service para expor seu aplicativo&lt;/a>
&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Doc K8S - Conceitos - Services, balanceamento de carga e rede - Services&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="namespaces">Namespaces&lt;/h2>
&lt;p>No Kubernetes, os namespaces fornecem um mecanismo para isolar grupos de recursos dentro de um cluster.&lt;/p>
&lt;p>Os nomes dos recursos precisam ser exclusivos dentro do namespace, mas não entre namespaces.&lt;/p>
&lt;p>Os namespaces não podem ser aninhados uns dentro dos outros e cada recurso do Kubernetes só pode estar em um namespace.&lt;/p>
&lt;p>Os namespaces são uma maneira de dividir os recursos do cluster entre vários usuários (por meio das &lt;a href="https://kubernetes.io/docs/concepts/policy/resource-quotas/" target="_blank" rel="noopener">resources quotas&lt;/a>
).&lt;/p>
&lt;p>
&lt;div class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 754px">
&lt;img class="card-img-top" src="https://sandrorgguimaraes.github.io/docs/certificacoes/cka/02_objetos/namespaces_hu0dce226aecd7a37245248683e66a16bb_40979_744x446_fill_box_smart1_3.png" width="744" height="446">
&lt;div class="card-body px-0 pt-2 pb-0">
&lt;p class="card-text"> &lt;/p>
&lt;/div>
&lt;/div>
Fonte.: &lt;a href="https://www.mshowto.org/kubernetes-namespace-terminating-problemi.html" target="_blank" rel="noopener">Kubernetes Namespace Terminating Problemi&lt;/a>
&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="noopener">Doc K8S - Conceitos - Visão geral - Trabalhando com objetos do Kubernetes - Namespaces&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/namespaces-walkthrough/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Passo a passo de namespaces&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Agendamento</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/03_agendamento/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/03_agendamento/</guid><description>
&lt;p>Um agendador observa os &lt;a href="../02_objetos/#pods">Pods&lt;/a>
recém-criados que não têm &lt;a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">Node&lt;/a>
atribuído. Para cada Pod que o agendador descobre, o agendador se torna responsável por encontrar o melhor &lt;a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">Node&lt;/a>
para esse Pod ser executado, uma vez concluído esse processo o &lt;a href="../01_componentes/#kubelet">Kubelet&lt;/a>
do node escolhido então coloca o pod em execução.&lt;/p>
&lt;p>O escalonador chega a esta decisão de posicionamento levando em consideração os princípios de escalonamento descritos abaixo.&lt;/p>
&lt;h2 id="agendamento-manual">Agendamento manual&lt;/h2>
&lt;p>Defina diretamente na especificação do &lt;a href="../02_objetos/#pods">Pods&lt;/a>
em qual &lt;a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">Node&lt;/a>
ele será executado.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Atribuindo pods a nós - nodeName&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="labels-e-selectors">Labels e Selectors&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Labels:&lt;/p>
&lt;ul>
&lt;li>São pares de chave/valor anexados a objetos, como pods.&lt;/li>
&lt;li>Devem ser usados ​​para especificar atributos de identificação de objetos que são significativos e relevantes para os usuários, mas não implicam diretamente na semântica do sistema central.&lt;/li>
&lt;li>Podem ser usados ​​para organizar e selecionar subconjuntos de objetos.&lt;/li>
&lt;li>Podem ser anexados a objetos no momento da criação e posteriormente adicionados e modificados a qualquer momento.&lt;/li>
&lt;li>Cada chave deve ser exclusiva para um determinado objeto.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Ao contrário de &lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names/" target="_blank" rel="noopener">nomes e UIDs&lt;/a>
, &lt;em>as labels não fornecem exclusividade&lt;/em>. Em geral, espera-se que muitos objetos tenham a(s) mesma(s) label(s).&lt;/p>
&lt;ul>
&lt;li>Selectors&lt;/li>
&lt;/ul>
&lt;p>Através de um label &lt;code>selector&lt;/code>, o cliente/usuário pode identificar um conjunto de objetos. O label selector é a primitiva de agrupamento principal no Kubernetes.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" target="_blank" rel="noopener">Doc K8S - Conceitos - Visão geral - Trabalhando com objetos do Kubernetes - Labels e Selectors&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="taints-e-tolerations">Taints e Tolerations&lt;/h2>
&lt;p>Enquanto &lt;a href="#node-affinity">Node Affinity&lt;/a>
é uma propriedade dos Pods que os atrai para um conjunto de nós (como uma preferência ou um requisito rígido), as &lt;code>Taints&lt;/code> são o oposto, elas &lt;em>permitem a um nó repelir um conjunto de pods&lt;/em>.&lt;/p>
&lt;p>As &lt;code>Tolerations&lt;/code> &lt;em>são aplicadas aos pods e permitem (mas não exigem)&lt;/em> que os pods sejam agendados em nós com &lt;code>Taints&lt;/code> correspondentes.&lt;/p>
&lt;p>As &lt;code>Taints&lt;/code> e as &lt;code>Tolerations&lt;/code> &lt;em>trabalham juntas para garantir&lt;/em> que os pods não sejam agendados em nós inadequados.&lt;/p>
&lt;p>Uma ou mais Taints pode(m) ser aplicadas a um nó, isso marca que o nó &lt;em>não deve aceitar&lt;/em> nenhum pod que não &lt;em>&lt;strong>tolere&lt;/strong>&lt;/em> essas Taints.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Taints e Tolerations&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="node-selectors">Node Selectors&lt;/h2>
&lt;p>&lt;code>nodeSelector&lt;/code> é a forma mais simples recomendada de restrição de seleção de nó.&lt;/p>
&lt;p>Ao adicionar o campo &lt;code>nodeSelector&lt;/code> à especificação do pod e definir as &lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#built-in-node-labels" target="_blank" rel="noopener">labels de nós&lt;/a>
que deseja que o nó de destino tenha, o Kubernetes agenda o pod apenas em nós que tenham cada uma das labels especificadas.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Atribuindo pods a nós - nodeSelector&lt;/a>
&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Atribuir pods a nós&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="node-affinity">Node Affinity&lt;/h2>
&lt;p>A &lt;code>Node Affinity&lt;/code> é conceitualmente semelhante a &lt;a href="#node-selectors">nodeSelector&lt;/a>
, permitindo restringir em quais nós o pod pode ser agendado com base em &lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#built-in-node-labels" target="_blank" rel="noopener">labels de nós&lt;/a>
.&lt;/p>
&lt;p>Existem dois tipos de &lt;code>Node Affinity&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>&lt;code>requiredDuringSchedulingIgnoredDuringExecution&lt;/code>: o agendador &lt;em>não pode agendar&lt;/em> o pod a menos que a regra seja atendida. Isso funciona como &lt;a href="#node-selectors">nodeSelector&lt;/a>
, &lt;em>mas com uma sintaxe mais expressiva&lt;/em>.&lt;/li>
&lt;li>&lt;code>preferredDuringSchedulingIgnoredDuringExecution&lt;/code>: o agendador &lt;em>tenta encontrar&lt;/em> um nó que atenda à regra. Se um nó correspondente não estiver disponível, o agendador &lt;em>ainda agendará&lt;/em> o pod.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Atribuindo pods a nós - Node affinity&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity" target="_blank" rel="noopener">Doc K8S - Conceitos - Agendamento, Preempção e Despejo - Atribuindo pods a nós - Affinity and anti-affinity&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Atribuir pods a nós usando afinidade de nó&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="taints-e-tolerations-x-node-affinity">Taints e Tolerations X Node Affinity&lt;/h2>
&lt;h2 id="resources-requirements-e-limits">Resources Requirements e Limits&lt;/h2>
&lt;p>Quando você define um Pod, você pode opcionalmente especificar quanto de cada recurso um Pod precisa, os recursos mais comuns a serem especificados são &lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu" target="_blank" rel="noopener">CPU&lt;/a>
e &lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory" target="_blank" rel="noopener">memória (RAM)&lt;/a>
; existem outros &lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-types" target="_blank" rel="noopener">tipos de recursos&lt;/a>
.&lt;/p>
&lt;p>Quando você especifica o &lt;code>requests&lt;/code> de um recurso para contêineres em um pod, o &lt;a href="../01_componentes/#scheduler">kube-scheduler&lt;/a>
usa essas informações para decidir em qual nó colocar o pod.&lt;/p>
&lt;p>Quando você especifica um &lt;code>limits&lt;/code> de recurso para um contêiner, o &lt;a href="../01_componentes/#kubelet">kubelet&lt;/a>
impõe esses &lt;code>limits&lt;/code> para que o contêiner em execução não tenha permissão para usar mais desse recurso do que o &lt;code>limits&lt;/code> definido.&lt;/p>
&lt;p>O &lt;a href="../01_componentes/#kubelet">kubelet&lt;/a>
também reserva pelo menos a quantidade de &lt;code>requests&lt;/code> desse recurso do sistema &lt;em>especificamente&lt;/em> para esse contêiner usar.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" target="_blank" rel="noopener">Doc K8S - Conceitos - Configuração - Gerenciamento de recursos para pods e contêineres&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Atribuir recursos de memória a contêineres e pods&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Gerenciar recursos de memória, CPU e API&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="daemonsets">DaemonSets&lt;/h2>
&lt;p>Um &lt;code>DaemonSet&lt;/code> garante que todos (ou alguns) nós executem uma cópia em um pod.&lt;/p>
&lt;p>À medida que os nós são adicionados ao cluster, os pods são adicionados a eles. À medida que os nós são removidos do cluster, esses pods são coletados como lixo.&lt;/p>
&lt;p>A exclusão de um &lt;code>DaemonSet&lt;/code> limpará os pods que ele criou.&lt;/p>
&lt;p>Alguns usos típicos de um &lt;code>DaemonSet&lt;/code> são:&lt;/p>
&lt;ul>
&lt;li>Executando um daemon de armazenamento de cluster em cada nó.&lt;/li>
&lt;li>Executando um daemon de coleta de logs em cada nó.&lt;/li>
&lt;li>Executando um daemon de monitoramento de nó em cada nó.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Recursos de carga de trabalho - DaemonSet&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/manage-daemon/" target="_blank" rel="noopener">Doc K8S - Tarefas - Gerenciar daemons de cluster&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="static-pods">Static Pods&lt;/h2>
&lt;p>Os &lt;code>Static Pods&lt;/code> são gerenciados diretamente pelo daemon &lt;a href="../01_componentes/#kubelet">kubelet&lt;/a>
em um nó específico, sem o &lt;a href="../01_componentes/#api-server">API Server&lt;/a>
observando-os.&lt;/p>
&lt;p>Enquanto a maioria dos Pods é gerenciada pelo &lt;a href="../01_componentes/#componentes-dos-master-nodes-ou-control-plane">Control Plane&lt;/a>
(por exemplo, um &lt;a href="../02_objetos/#deployments">Deployments&lt;/a>
), para &lt;code>Static Pods&lt;/code>, o &lt;a href="../01_componentes/#kubelet">kubelet&lt;/a>
supervisiona diretamente cada &lt;code>Static Pods&lt;/code> (e o reinicia se falhar).&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/#static-pods" target="_blank" rel="noopener">Doc K8S - Conceitos - Cargas de trabalho - Pods&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/" target="_blank" rel="noopener">Doc K8S - Tarefas - Configurar pods e contêineres - Criar pods estáticos&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="multiplos-kubernetes-schedulers">Multiplos Kubernetes Schedulers&lt;/h2>
&lt;p>Se o agendador padrão não atender às suas necessidades, você pode implementar seu próprio agendador. Além disso, você pode até executar vários agendadores simultaneamente ao lado do agendador padrão e instruir o Kubernetes sobre qual agendador usar para cada um de seus pods.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/extend-kubernetes/configure-multiple-schedulers/" target="_blank" rel="noopener">Doc K8S - Tarefas - Estender Kubernetes - Configurar vários agendadores&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Docs: Log &amp; Monitoração</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/04_log_monitoracao/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/04_log_monitoracao/</guid><description>
&lt;h2 id="monitorar-os-componentes-do-cluster">Monitorar os componentes do cluster&lt;/h2>
&lt;p>Para Kubernetes, a &lt;a href="https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/#metrics-api" target="_blank" rel="noopener">API Metrics&lt;/a>
oferece um conjunto básico de métricas para dar suporte ao dimensionamento automático e casos de uso semelhantes.&lt;/p>
&lt;p>Essa API disponibiliza informações sobre o uso de recursos para nó e pod, incluindo métricas para CPU e memória.&lt;/p>
&lt;p>Se você implantar a API de métricas em seu cluster, os clientes da API do Kubernetes poderão consultar essas informações e você poderá usar os mecanismos de controle de acesso do Kubernetes para gerenciar permissões para fazer isso.&lt;/p>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de clusters - Pipeline de métricas de recursos&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-usage-monitoring/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de clusters - Ferramentas para monitorar recursos&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/" target="_blank" rel="noopener">Doc K8S - Tarefas - Administrar um cluster - Gerenciar recursos de memória, CPU e API&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="acompanhar-os-logs-das-aplicações">Acompanhar os logs das aplicações&lt;/h2>
&lt;blockquote>
&lt;p>Link&amp;rsquo;s úteis:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/pt-br/docs/concepts/cluster-administration/logging/#log-b%C3%A1sico-no-kubernentes" target="_blank" rel="noopener">Doc K8S - Conceitos - Administração de Cluster - Arquitetura de Log&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-application/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de Aplicativos&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-application/debug-pods/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de Aplicativos - Debug Pods&lt;/a>
&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/debug/debug-application/determine-reason-pod-failure/" target="_blank" rel="noopener">Doc K8S - Tarefas - Monitoramento, Logs e Debug - Troubleshooting de Aplicativos - Determinar o motivo da falha do Pod&lt;/a>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Troubleshooting Applications&lt;/p></description></item><item><title>Docs: Gerenciar Ciclos de Vida de Aplicações</title><link>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/05_gerenciar_apps/</link><pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate><guid>https://sandrorgguimaraes.github.io/docs/certificacoes/cka/05_gerenciar_apps/</guid><description>
&lt;h2 id="rolling-updates-e-rollbacks">Rolling Updates e Rollbacks&lt;/h2>
&lt;h2 id="configurando-aplicações">Configurando aplicações&lt;/h2>
&lt;h3 id="comandos-e-argumentos">Comandos e Argumentos&lt;/h3>
&lt;h3 id="variáveis-de-ambiente">Variáveis de ambiente&lt;/h3>
&lt;h3 id="configmaps">ConfigMaps&lt;/h3>
&lt;h3 id="secrets">Secrets&lt;/h3>
&lt;h2 id="pods-com-multiplos-containers">Pods com multiplos containers&lt;/h2>
&lt;h2 id="initcontainers">InitContainers&lt;/h2>
&lt;h2 id="self-healing-auto-cura-das-aplicações">Self Healing (auto cura) das aplicações&lt;/h2>
&lt;p>O Kubernetes oferece suporte de self healing (auto recuperação) a aplicativos por meio de &lt;a href="../02_objetos/#replicasets">ReplicaSets&lt;/a>
.&lt;/p>
&lt;p>O &lt;a href="../02_objetos/#replicasets">ReplicaSets&lt;/a>
ajuda a garantir que um POD seja recriado automaticamente quando o aplicativo dentro do POD trava, isso ajuda a garantir que réplicas suficientes do aplicativo estejam em execução o tempo todo.&lt;/p>
&lt;p>O Kubernetes fornece suporte adicional para verificar a integridade dos aplicativos executados em PODs e realizar as ações necessárias por meio de &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-command" target="_blank" rel="noopener">Liveness Probes&lt;/a>
e &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes" target="_blank" rel="noopener">Readiness Probes&lt;/a>
, porém esses 2 (dois) tópicos são para o exame &lt;a href="https://www.cncf.io/certification/ckad/" target="_blank" rel="noopener">Certified Kubernetes Application Developers (CKAD)&lt;/a>
, não são abordados nesta certificação para CKA.&lt;/p></description></item></channel></rss>